import numpy as np
from scipy.sparse import csr_matrix


def sigmoid(x):
    return 1 / (1 + np.exp(-x))


def softmax(x, axis=-1):
    x = x - np.expand_dims(x.max(axis=axis), axis=axis).repeat(x.shape[axis], axis)
    x = np.exp(x)
    return x / np.expand_dims(x.sum(axis), axis=axis).repeat(x.shape[axis], axis)


# Generates synthetic random graphs
def gen_network(n=100, kms=None, pi=None, B=None, feat_probs=None):
    """
    Generates a synthetic random graph using Attribute SBM model
    :param n: Number of nodes in the graph
    :param kms: List of number of values that the attributes can take
    :param pi: Probability of belonging to different communities as a one dimensional numpy array
    :param B: List of block matrices for all attributes
    :param feat_probs: List of feature probabilities for all features
    :return: adj_mat, features, ground_truth
        adj_mat: (N x N) symmetric adjacency matrix with no self loop randomly generated by ASBM
        features: (N x M) feature matrix, each row represents a node
        ground_truth: (N x _) Ground truth communities
    """
    # Check condition on n
    assert n > 0, "Number of nodes has to be greater than 0"

    # Check condition on Kms
    if kms is None:
        kms = [2, 2]
    assert all(km > 0 for km in kms), "Number of values for attributes can not be negative"
    m = len(kms)    # Number of attributes

    # Check condition on pi
    if pi is None:
        pi = np.ones((2,)) / 2
    assert pi.sum() == 1, "pi values should sum up to one"
    assert all(pi[i] > 0 for i in range(pi.shape[0])), "pi values can not be negative"
    l = pi.shape[0]     # Number of communities

    # Check condition on B
    if B is None:
        B = [1 / (1 + np.exp(-np.eye(kms[i] * l) - np.random.normal(size=(kms[i] * l, kms[i] * l)))) for i in range(m)]
        B = [(B[i] + B[i].T) / 2 for i in range(m)]
    assert len(B) == m, "Must provide exactly m block matrices, one for each attribute"
    assert all(B[i].shape[0] == B[i].shape[1] for i in range(m)), "All B matrices should be square"
    assert all(B[i].shape[0] == l * kms[i] for i in range(m)), "Incorrect shape for B matrix has been specified"

    # Check condition on feat_probs
    if feat_probs is None:
        feat_probs = [np.ones((kms[j],)) / kms[j] for j in range(m)]
    assert len(feat_probs) == m, "Feature probabilities have to be specified for all features"
    assert all(all(0 <= feat_probs[i][j] <= 1 for j in range(kms[i])) for i in range(m)), "Invalid values in feat_probs"

    # Sample the communities
    ground_truth = np.random.choice(range(l), size=n, replace=True, p=pi)
    ground_truth = ground_truth.astype(int)

    # Sample the attributes
    features = np.zeros((n, m))
    for j in range(m):
        features[:, j] = np.random.choice(range(kms[j]), size=n, replace=True, p=feat_probs[j])
    features = features.astype(int)

    # Sample the edges
    adj_mat = np.zeros((n, n))
    for i in range(n):
        for j in range(i):
            p = 1
            for k in range(m):
                li = ground_truth[i]
                lj = ground_truth[j]
                ki = features[i, k]
                kj = features[j, k]
                p *= B[k][ki * l + li, kj * l + lj]
            adj_mat[i, j] = adj_mat[j, i] = (np.random.random() <= p).astype(int)
    adj_mat = adj_mat.astype(int)

    return adj_mat, features, ground_truth


def rbm_sample(M, K, W, b, c, chain_length=10, num_samples=1, start_with_z=True):
    """
    :param M: Number of attributes
    :param K: Number of communities
    :param W: (M, K) Weight matrix for RBM
    :param b: (M, 1) Bias terms for features
    :param c: (K, 1) Bias terms for communities
    :param chain_length: Number of steps to take for Gibbs sampling
    :param num_samples: Number of samples to generate
    :param start_with_z: Whether to start the Gibbs chain by sampling z
    returns: y, z
        y: (num_samples, M) Sampled y values
        z: (num_samples, K) Sampled z values
    """
    y = (np.random.random(size=(num_samples, M)) <= 0.5).astype(float)

    idx = np.random.choice(K, size=num_samples, replace=True)
    z = np.zeros((num_samples, K))
    z[np.arange(num_samples), idx] = 1

    for _ in range(chain_length):
        if start_with_z:
            z = softmax(np.matmul(y, W) + c.repeat(num_samples, axis=1).T)    # num_samples x K
            idx = [np.random.choice(K, size=1, p=z[i, :])[0] for i in range(num_samples)]
            z = np.zeros((num_samples, K))
            z[np.arange(num_samples), idx] = 1
            y = sigmoid(np.matmul(z, W.T) + b.repeat(num_samples, axis=1).T) # num_samples x M
            y = (np.random.random(y.shape) <= y).astype(float)
        else:
            y = sigmoid(np.matmul(z, W.T) + b.repeat(num_samples, axis=1).T) # num_samples x M
            y = (np.random.random(y.shape) <= y).astype(float)
            z = softmax(np.matmul(y, W) + c.repeat(num_samples, axis=1).T)    # num_samples x K
            idx = [np.random.choice(K, size=1, p=z[i, :])[0] for i in range(num_samples)]
            z = np.zeros((num_samples, K))
            z[np.arange(num_samples), idx] = 1
    return y, z


# Generates synthetic random graphs
def gen_network_rbmsbm(W, b, c, B, N=100, directed=True):
    """
    Generates a synthetic random graph using RBMSBM model
    :param N: Number of nodes in the graph
    :param W: (M, K) Weight matrix for RBM
    :param b: (M, 1) Bias terms for features
    :param c: (K, 1) Bias terms for communities
    :param B: (K, K) Block matrix for SBM
    :param directed: Whether to generate a directed network or not
    :return: adj_mat, features, ground_truth
        adj_mat: (N x N) adjacency matrix with no self loop
        features: (N x M) feature matrix, each row represents a node
        ground_truth: (N x 1) Ground truth communities
    """
    # Useful variables
    M = b.shape[0]
    K = c.shape[0]

    # Sample the nodes features are communities
    features, Z = rbm_sample(M, K, W, b, c, chain_length=100, num_samples=N)
    ground_truth = np.argmax(Z, axis=1)

    # Sample the edges
    probs = np.matmul(Z, np.matmul(B, Z.T))
    adj_mat = (np.random.random((N, N)) <= probs).astype(float)

    if directed:
        adj_mat = np.triu(adj_mat, 1) + np.triu(adj_mat.T, 1).T
    else:
        adj_mat = np.triu(adj_mat, 1)
        adj_mat = adj_mat + adj_mat.T

    return adj_mat, features, ground_truth


# Generates synthetic random graphs
def gen_network_rbmsbm_loop(W, b, c, B, N=100, step=10000):
    """
    Generates a synthetic random graph using RBMSBM model
    :param N: Number of nodes in the graph
    :param W: (M, K) Weight matrix for RBM
    :param b: (M, 1) Bias terms for features
    :param c: (K, 1) Bias terms for communities
    :param B: (K, K) Block matrix for SBM
    :param step: Number of nodes to cover in a single step
    :return: adj_mat, features, ground_truth
        adj_mat: (N x N) adjacency matrix with no self loop
        features: (N x M) feature matrix, each row represents a node
        ground_truth: List of ground truth communities
    """
    if step > N:
        step = N

    # Useful variables
    M = b.shape[0]
    K = c.shape[0]
    num_steps = int(N / step)

    # Sample the nodes features are communities
    ground_truth = []
    row = []
    col = []
    data = []
    for s in range(num_steps):
        features, Z = rbm_sample(M, K, W, b, c, chain_length=1000, num_samples=step)
        ground_truth += np.argmax(Z, axis=1).tolist()
        indices = np.nonzero(features)
        row += (s * step + indices[0]).tolist()
        col += indices[1].tolist()
        data += [1] * indices[0].shape[0]
    features = csr_matrix((data, (row, col)), shape=(N, M))

    # Sample the edges
    row = []
    col = []
    data = []
    for i in range(num_steps):
        for j in range(num_steps):
            Z1 = np.zeros((step, K))
            Z1[np.arange(step), np.asarray(ground_truth[step * i: step * i + step])] = 1
            Z2 = np.zeros((step, K))
            Z2[np.arange(step), np.asarray(ground_truth[step * j: step * j + step])] = 1

            probs = np.matmul(Z1, np.matmul(B, Z2.T))
            indices = np.nonzero(np.random.random((step, step)) <= probs)
            row += (i * step + indices[0]).tolist()
            col += (j * step + indices[1]).tolist()
            data += [1] * indices[0].shape[0]
    adj_mat = csr_matrix((data, (row, col)), shape=(N, N))

    for i in range(N):
        adj_mat[i, i] = 0

    return adj_mat, features, ground_truth



def gen_network_sbm_loop(W, B, N=100, step=10000):
    """
    Generates a synthetic random graph using SBM with attributes as described by one of the reviewers
    :param N: Number of nodes in the graph
    :param W: (M, K) (m, k)^th entry specifies the probability of m^th attribute being 1 in community k
    :param B: (K, K) Block matrix for SBM
    :param step: Number of nodes to cover in a single step
    :return: adj_mat, features, ground_truth
        adj_mat: (N x N) adjacency matrix with no self loop
        features: (N x M) feature matrix, each row represents a node
        ground_truth: List of ground truth communities
    """
    if step > N:
        step = N

    # Useful variables
    M = W.shape[0]
    K = W.shape[1]
    num_steps = int(N / step)


    # Sample the communities
    ground_truth = []
    for i in range(N):
        ground_truth.append(np.random.choice(K))
    Z = np.eye(K)[ground_truth, :]


    # Sample the node features
    features = np.matmul(Z, W.T)
    features = (np.random.random(features.shape) <= features).astype(float)
    features = csr_matrix(features)


    # Sample the edges
    row = []
    col = []
    data = []
    for i in range(num_steps):
        for j in range(num_steps):
            Z1 = Z[step * i: step * i + step, :]
            Z2 = Z[step * j: step * j + step, :]

            probs = np.matmul(Z1, np.matmul(B, Z2.T))
            indices = np.nonzero(np.random.random((step, step)) <= probs)
            row += (i * step + indices[0]).tolist()
            col += (j * step + indices[1]).tolist()
            data += [1] * indices[0].shape[0]
    adj_mat = csr_matrix((data, (row, col)), shape=(N, N))

    for i in range(N):
        adj_mat[i, i] = 0

    return adj_mat, features, ground_truth


if __name__ == '__main__':
    N = 100; M = 10; K = 8
    W = np.random.normal(size=(M, K))
    b = np.random.normal(size=(M, 1))
    c = np.random.normal(size=(K, 1))
    B = sigmoid(np.random.normal(loc=-3, scale=0.1, size=(K, K)) + 3*np.eye(K))
    A, X, Z = gen_network_rbmsbm(W, b, c, B, N)

    import visualize_communities as vc
    vc.visualize_graph(A, Z)
